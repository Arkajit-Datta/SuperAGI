from typing import Type, Optional

from pydantic import BaseModel, Field

# from superagi.helper.s3_helper import upload_to_s3
from superagi.resource_manager.file_manager import FileManager
from superagi.tools.base_tool import BaseTool
from superagi.llms.base_llm import BaseLlm
from superagi.helper.prompt_reader import PromptReader
from superagi.tools.tool_response_query_manager import ToolResponseQueryManager

# from superagi.helper.s3_helper import upload_to_s3


class WriteFileInput(BaseModel):
    """Input for CopyFileTool."""
    file_name: str = Field(..., description="Name of the file to write. Only include the file name. Don't include path.")
    content: str = Field(..., description="File content to write")


class WriteFileTool(BaseTool):
    """
    Write File tool

    Attributes:
        name : The name.
        description : The description.
        agent_id: The agent id.
        args_schema : The args schema.
        resource_manager: File resource manager.
    """
    llm: Optional[BaseLlm] = None
    name: str = "Write File"
    args_schema: Type[BaseModel] = WriteFileInput
    description: str = "Writes text to a file"
    agent_id: int = None
    resource_manager: Optional[FileManager] = None
    tool_response_manager: Optional[ToolResponseQueryManager] = None
    
    class Config:
        arbitrary_types_allowed = True

    def _execute(self, file_name: str, content: str):
        """
        Execute the write file tool.

        Args:
            file_name : The name of the file to write.
            content : The text to write to the file.

        Returns:
            success message if message is file written successfully or failure message if writing file fails.
        """
        file_type = file_name.split('.')[-1].lower()
        print(f"--------------{file_type}----------------")
        if file_type not in ['pdf', 'docx', 'doc']:
            return self.resource_manager.write_file(file_name, content)
        
        html_code_content = self._convert_content_into_html(content=content)
        return self.resource_manager.write_file(file_name, html_code_content)

    def _convert_content_into_html(self, content: str) -> str:
        """
        Converts the content into an HTML file
        Args:
            content (str): Content to be beautified and formatted
        Returns:
            HTML Code (str): HTML code of the formated content 
        """
        prompt = PromptReader.read_tools_prompt(__file__, "content_to_html_prompt.txt")
        prompt = prompt.replace("{content}", content)

        if image_file_paths := self._get_file_path_from_image_generation_tool():
            embedding_image_prompt = PromptReader.read_tools_prompt(__file__, "add_images_to_html.txt")
            for idx, image_path in enumerate(image_file_paths):
                embedding_image_prompt += f"\n{idx+1}. {image_path}"
            prompt = prompt.replace("{embedding_image}", embedding_image_prompt)
        else:
            prompt = prompt.replace("{embedding_image}", "")

        messages = [{"role": "system", "content": prompt}]
        result = self.llm.chat_completion(messages, max_tokens=self.max_token_limit)
        return result['content']
    
    def _get_file_path_from_image_generation_tool(self) -> list:
        """
        Parses the output of the previous tool (Stable diffusion) and returns the path of the image file

        Args:

        Returns:
            The path of the image file generated by the image generation toolkit
        """
        
        last_tool_response = self.tool_response_manager.get_last_response()
        file_path="resources"+last_tool_response.partition("['")[2].partition("']")[0]
        image_file_paths = []

        if ',' in file_path:
            # Split the string based on the comma and get the first element (substring before the comma)
            file_path = file_path.split(',')[0].strip()
            image_file_paths = file_path[:-1]
        print(image_file_paths)
        return image_file_paths