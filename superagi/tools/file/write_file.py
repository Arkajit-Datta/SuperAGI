from typing import Type, Optional
import base64

from pydantic import BaseModel, Field

# from superagi.helper.s3_helper import upload_to_s3
from superagi.resource_manager.file_manager import FileManager
from superagi.tools.base_tool import BaseTool
from superagi.llms.base_llm import BaseLlm
from superagi.helper.prompt_reader import PromptReader
from superagi.tools.tool_response_query_manager import ToolResponseQueryManager

# from superagi.helper.s3_helper import upload_to_s3


class WriteFileInput(BaseModel):
    """Input for CopyFileTool."""
    file_name: str = Field(..., description="Name of the file to write. Only include the file name. Don't include path.")
    content: str = Field(..., description="File content to write")


class WriteFileTool(BaseTool):
    """
    Write File tool

    Attributes:
        name : The name.
        description : The description.
        agent_id: The agent id.
        args_schema : The args schema.
        resource_manager: File resource manager.
    """
    llm: Optional[BaseLlm] = None
    name: str = "Write File"
    args_schema: Type[BaseModel] = WriteFileInput
    description: str = "Writes content in a file. The content can carry text and images."
    agent_id: int = None
    resource_manager: Optional[FileManager] = None
    tool_response_manager: Optional[ToolResponseQueryManager] = None
    
    class Config:
        arbitrary_types_allowed = True

    def _execute(self, file_name: str, content: str):
        """
        Execute the write file tool.

        Args:
            file_name : The name of the file to write.
            content : The text to write to the file.

        Returns:
            success message if message is file written successfully or failure message if writing file fails.
        """
        file_type = file_name.split('.')[-1].lower()
        
        if file_type not in ['pdf', 'docx', 'doc']:
            return self.resource_manager.write_file(file_name, content)
        
        html_code_content = self._convert_content_into_html(content=content, formated_for=file_type)
        return self.resource_manager.write_file(file_name, html_code_content)

    def _convert_content_into_html(self, content: str, formated_for: str) -> str:
        """
        Converts the content into an HTML file
        Args:
            content (str): Content to be beautified and formatted
            formated_for (str): HTML content to be specifically formatted for a specific document type
        Returns:
            HTML Code (str): HTML code of the formated content 
        """
        prompt = PromptReader.read_tools_prompt(__file__, "content_to_html_prompt.txt")
        prompt = prompt.replace("{content}", content)

        if image_file_paths := self._get_file_path_from_image_generation_tool():
            embedding_image_prompt = PromptReader.read_tools_prompt(__file__, "add_images_to_html.txt")
            for idx, image_path in enumerate(image_file_paths):
                embedding_image_prompt += f"\n{idx+1}. {image_path}"
            prompt = prompt.replace("{embedding_image}", embedding_image_prompt)
        else:
            prompt = prompt.replace("{embedding_image}", "")
            
        messages = [{"role": "system", "content": prompt}]
        result = self.llm.chat_completion(messages, max_tokens=self.max_token_limit)
        
        if formated_for == 'pdf':
            return self._html_formatting_for_pdf(content=result["content"], image_list=image_file_paths)
        return result['content']
    
    def _get_file_path_from_image_generation_tool(self) -> list:
        """
        Parses the output of the Image Generation tool (Stable diffusion / Dalle) and returns the path of the image file

        Returns:
            The path of the image file generated by the image generation toolkit
        """
        
        tool_responses = self.tool_response_manager.get_responses(tool_names=["Stable Diffusion", "Dalle"])
    
        all_image_paths = []
        for tool_response in tool_responses:
            # Iterating through all the tool responses to find the image paths in it. 
            file_path = tool_response.partition("['")[2].partition("']")[0]
            file_path = file_path.replace("'", "").replace('"', '').replace(" ","").strip()
            print("file path after partition -> ", file_path)

            file_path = file_path.split(',') if ',' in file_path else [file_path]
            all_image_paths.extend(file_path)

        return all_image_paths
    
    def _image_to_base64(self, image_path):
        with open(image_path, "rb") as image_file:
            encoded_image = base64.b64encode(image_file.read()).decode("utf-8")
        return encoded_image
    
    def _html_formatting_for_pdf(self, content: str, image_list: list) -> str:
        """
        Converts image paths into base64 inputs in an HTML file
        Args:
            content (str): HTML code
            image_list (list): List of images to be converted and replaced
        Returns:
            HTML Code (str): Formatted HTML code 
        """
        
        for image_path in image_list:
            content = content.replace(f"{image_path}", f"data:image/png;base64,{self._image_to_base64(image_path=image_path)}")
        return content